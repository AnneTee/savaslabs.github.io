---
layout: post
title: Our Jekyll Workflow
date: 2016-10-07
author: Anne Tomasevich
tags: performance jekyll javascript css sass front-end-dev best-practices
summary: |
  How we improved our company site's performance with a better Jekyll workflow
featured_image: "/blog/usability-testing.jpg"
featured_image_alt: "Two people comparing notes while using computers"
---

It's hard to believe it's been over a year and a half since our site's 
[inaugural blog post](http://localhost:3000/2015/04/01/building-our-site.html)
(written just two months after my career change into web development!) It's been
great fun building our site and adding content thanks to the power and simplicity
of [Jekyll](https://jekyllrb.com/). We recently deployed a series of changes to
optimize our CSS, JS, and images and, in doing so, finally moved away from using
built-in `jekyll` commands to build the site. Instead, we're using
[gulp](http://gulpjs.com/), a task runner (or, as they put so nicely on their
website, a "streaming build system"). In this post I'll go over our motivations
for this change, how we integrated gulp with Jekyll, and the awesome results!

We based a lot of our gulp workflow on 
[this great post](https://robwise.github.io/blog/jekyll-and-gulp) by Rob Wise.
Our workflow also includes separate gulp tasks for building the site locally,
for testing purposes, and for production, as well as some updated gulp plugins,
but I'd definitely recommend his post and you'll see some of his code and
architecture throughout this article.

To see all of our current code, pop over to our
[GitHub repo](https://github.com/savaslabs/savaslabs.github.io).

## Why the changes?



## Initial setup

### Changes to Jekyll directory structure

Our fonts, images, scripts, and SCSS files were previously stored in a directory
called `assets`. The `jekyll build` command would copy this directory into the
`_site` folder so the assets within could be included in HTML files and used to
theme the site.

```bash
~/Sites/savaslabs.com/assets $ tree -L 1
.
├── fonts
├── img
├── js
└── styles
```

Since we're going to be processing our assets with gulp instead, we moved the
`assets` directory to `_assets` to indicate that it should be ignored by Jekyll.

Our basic workflow will be to use gulp to process the contents of `_assets`,
outputting them into a git-ignored directory `assets` which will be copied by
Jekyll into the generated `_site` directory. In addition, we will create a `gulp
serve` task using `gulp.watch()` to process assets as they're updated and copy
them directly into the `_site` directory, then push the changes to the Browser
via BrowserSync.

![Diagram of our basic gulp workflow]({{ site.url }}/assets/img/blog/gulp-workflow.svg)

### Changes to Jekyll config

We also needed to make some updates to our Jekyll config:

```yaml
# Delete this since Jekyll is no longer processing sass.
sass:
  sass_dir: assets/styles

# Exclude the following from the Jekyll build process.
# Note: "vendor" is for Travis CI.
exclude: ["vendor",
          "_assets",
          "Gemfile",
          "Gemfile.lock",
          "gulpfile.js",
          "node_modules",
          "package.json"]
 
```

I'd also like to note that we're using a few different config files: our default
`_config.yml`, `_config.test.yml` which uses blank URL and base URL variables so
tests can be run locally, and `_config.dev.yml` which sets variables for our
local [comment server](https://github.com/savaslabs/squabble) for development
purposes. These different config files will come into play as we set up the
gulpfile.

Finally, we updated our .gitignore to include the following:

```
node_modules
assets
```

`node_modules` will hold all of our node.js dependencies, and `assets` is the
directory that will be generated by gulp and copied by Jekyll into the `_site`
directory. The `assets` directory (no underscore) will hold processed asset
files and we'll only be keeping the unprocessed files (the `_assets` directory)
in version control.

### Paths file

This comes straight from [Rob's post](https://robwise.github.io/blog/jekyll-and-gulp)
and is a great organizational technique. In the `_assets` directory, I created a
directory called `gulp_config` to hold `paths.js`, a list of all the paths we'll
need set to javascript variables to be used in the gulpfile. We're going to be
piping a lot of files to and from gulp tasks and they'll need to land in very
specific locations so settings these variables in one place will keep us
consistent.

```js
// paths.js file

var paths = {};

// Directory locations.
paths.assetsDir       = '_assets/';      // The files Gulp will handle.
paths.jekyllDir       = '';              // The files Jekyll will handle.
paths.jekyllAssetsDir = 'assets/';       // The asset files Jekyll will handle.
paths.siteDir         = '_site/';        // The resulting static site.
paths.siteAssetsDir   = '_site/assets/'; // The resulting static site's assets.

// Folder naming conventions.
paths.postFolderName   = '_posts';
paths.draftFolderName  = '_drafts';
paths.fontFolderName   = 'fonts';
paths.imageFolderName  = 'img';
paths.scriptFolderName = 'js';
paths.stylesFolderName = 'styles';

// Asset files locations.
paths.sassFiles   = paths.assetsDir + paths.stylesFolderName;
paths.jsFiles     = paths.assetsDir + paths.scriptFolderName;
paths.imageFiles  = paths.assetsDir + paths.imageFolderName;
paths.fontFiles   = paths.assetsDir + paths.fontFolderName;

// Jekyll files locations.
paths.jekyllPostFiles  = paths.jekyllDir       + paths.postFolderName;
paths.jekyllDraftFiles = paths.jekyllDir       + paths.draftFolderName;
paths.jekyllCssFiles   = paths.jekyllAssetsDir + paths.stylesFolderName;
paths.jekyllJsFiles    = paths.jekyllAssetsDir + paths.scriptFolderName;
paths.jekyllImageFiles = paths.jekyllAssetsDir + paths.imageFolderName;
paths.jekyllFontFiles  = paths.jekyllAssetsDir + paths.fontFolderName;

// Site files locations.
paths.siteCssFiles   = paths.siteAssetsDir + paths.stylesFolderName;
paths.siteJsFiles    = paths.siteAssetsDir + paths.scriptFolderName;
paths.siteImageFiles = paths.siteAssetsDir + paths.imageFolderName;
paths.siteFontFiles  = paths.siteAssetsDir + paths.fontFolderName;

// Glob patterns by file type.
paths.sassPattern     = '/**/*.scss';
paths.jsPattern       = '/**/*.js';
paths.imagePattern    = '/**/*.+(jpg|JPG|jpeg|JPEG|png|PNG|svg|SVG|gif|GIF|webp|WEBP|tif|TIF)';
paths.markdownPattern = '/**/*.+(md|MD|markdown|MARKDOWN)';
paths.htmlPattern     = '/**/*.html';
paths.xmlPattern      = '/**/*.xml';

// Asset files globs
paths.sassFilesGlob  = paths.sassFiles  + paths.sassPattern;
paths.jsFilesGlob    = paths.jsFiles    + paths.jsPattern;
paths.imageFilesGlob = paths.imageFiles + paths.imagePattern;

// Jekyll files globs
paths.jekyllPostFilesGlob  = paths.jekyllPostFiles  + paths.markdownPattern;
paths.jekyllDraftFilesGlob = paths.jekyllDraftFiles + paths.markdownPattern;
paths.jekyllHtmlFilesGlob  = paths.jekyllDir        + paths.htmlPattern;
paths.jekyllXmlFilesGlob   = paths.jekyllDir        + paths.xmlPattern;
paths.jekyllImageFilesGlob = paths.jekyllImageFiles + paths.imagePattern;

// Site files globs
paths.siteHtmlFilesGlob = paths.siteDir + paths.htmlPattern;

module.exports = paths;
```

Later we'll include this file in our gulpfile so the variables can be accessed.

### Install dependencies

The first requirements are node.js and npm, which you can learn about installing [here](https://docs.npmjs.com/getting-started/installing-node).

Getting gulp set up is a matter of a few commands:

```bash
# Install gulp globally.
npm install -g gulp

# Initialize the project, following the prompts
# (most of which can be left blank and filled in later).
npm init

# Now that package.json has been created, start adding dependencies.
npm install --save-dev gulp

# Create a gulpfile in the root of the repository.
touch gulpfile.js
```

### Include paths

```js
var paths = require('./_assets/gulp_config/paths');
```

### Outline gulp tasks

```
// Define variables.

// Process SCSS.
gulp.task('build:styles', function() {
  // Compile SCSS, run autoprefixer, and minify CSS.
});

// Process JS.
gulp.task('build:scripts', function() {
  // Concatenate and uglify JS.
});

// Optimizes images.
gulp.task('build:images', function() {
  // Run imagemin.
});

// Runs jekyll build command.
gulp.task('build:jekyll', function() {
  // Run bundle exec jekyll build with appropriate config file.
});

// Builds site anew.
gulp.task('build', function() {
  // Run all build tasks.
});

// Default Task: builds site.
gulp.task('default', ['build']);

// Serve site and watch files.
gulp.task('serve', ['build'], function() {
  // Watch for changes and run appropriate build tasks when needed.
});
```

## Handle CSS

Jekyll compiles SCSS out of the box, but using gulp to process our SCSS gives us the power to do other useful things like minify our CSS, add vendor prefixes, and direct our critical CSS to the `<head>` element.

### Process all SCSS

```js
var autoprefixer = require('autoprefixer');
var cleancss    = require('gulp-clean-css');
var postcss     = require('gulp-postcss');
var sass        = require('gulp-ruby-sass');

// Uses Sass compiler to process styles, adds vendor prefixes, minifies, then
// outputs file to the appropriate location.
gulp.task('build:styles', function() {
    return sass(paths.sassFiles + '/main.scss', {
        style: 'compressed',
        trace: true,
        loadPath: [paths.sassFiles]
    }).pipe(postcss([ autoprefixer({ browsers: ['last 2 versions'] }) ]))
        .pipe(cleancss())
        .pipe(gulp.dest(paths.jekyllCssFiles))
        .pipe(gulp.dest(paths.siteCssFiles))
        .pipe(browserSync.stream())
        .on('error', gutil.log);
});
```

Some notes:

- We're including all our SCSS partials in our [main.scss](), but you could point to a directory or file glob if needed.
- We're using the [autoprefixer plugin](https://github.com/postcss/autoprefixer) for postcss. We're making heavy use of the Bourbon mixin library which currently handles some autoprefixing, but this will be dropped (hopefully soon!) in Bourbon v5.0 at which time [autoprefixer will be recommended](https://github.com/postcss/autoprefixer)

### Critical CSS

## Compile/process JS

### async

## Process images

### manual updates to images

### imagemin

### picture tag

## The Results

After implementing these changes, our PageSpeed score shot up to a beautiful 96/100!

TODO: fill this in with screenshot

To pat myself on the back a little more, I should mention that we were already doing great in the user experience department.

<img src="/assets/img/blog/pagespeed-insights-user-experience.jpg" class="blog-image-xl" alt="Passing Google PageSpeed Insights user experience items.">

<img src="/assets/img/blog/liz-lemon-self-five.gif" class="blog-image" style="max-width: 300px;" alt="Tina Fey as Liz Lemon giving herself an awesome high five.">



I've been a big fan of [Jekyll](https://jekyllrb.com/) since we began using it to build our company website, and it's hard to imagine a simpler hosting provider than the wonderful (and free) [GitHub Pages](https://pages.github.com/). In a work environment full of VMs and Docker containers and giant databases to import and complex hosting environments, I've learned to enjoy spinning up my local Jekyll site, making a few changes, and pushing to master to let GitHub Pages do the rest.

<br>

<img src="/assets/img/blog/pagespeed-insights-initial.jpg" class="blog-image-xl" alt="Initial Google PageSpeed Insights score for savaslabs.com. Several significant problems exist!">
<span class="caption">Wrong.</span>

## Reality check, brought to you by Google PageSpeed Insights

At first the perfectionist in me was affronted by the seemingly harsh 54/100 score (not to mention the scary orange and red exclamation points), but PageSpeed gives us all kinds of useful information about exactly what we can do to improve performance in each area. Clicking on "Show how to fix" expands a more detailed explanation of the issue and a link to an relevant article for further information. Thanks to PageSpeed, we knew we needed to:

1. Optimize our images
2. Change the way we're serving up CSS and JS assets so "above the fold" content isn't blocked by loading these items
3. Minify our CSS

TODO: talk about "leverage browser caching"

## The Plan

To solve these issues, we decided to use a taskrunner to process CSS, JS, and image asset, do some manual image optimization, and use the Jekyll Picture Tag plugin to help us serve up appropriately-sized images depending on screen size and resolution.

